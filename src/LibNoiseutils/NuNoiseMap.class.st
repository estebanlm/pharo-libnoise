"
/// Implements a noise map, a 2-dimensional array of floating-point
    /// values.
    ///
    /// A noise map is designed to store coherent-noise values generated by a
    /// noise module, although it can store values from any source.  A noise
    /// map is often used as a terrain height map or a grayscale texture.
    ///
    /// The size (width and height) of the noise map can be specified during
    /// object construction or at any other time.
    ///
    /// The GetValue() and SetValue() methods can be used to access individual
    /// values stored in the noise map.
    ///
    /// This class manages its own memory.  If you copy a noise map object
    /// into another noise map object, the original contents of the noise map
    /// object will be freed.
    ///
    /// If you specify a new size for the noise map and the new size is
    /// smaller than the current size, the allocated memory will not be
    /// reallocated.
    /// Call ReclaimMem() to reclaim the wasted memory.
    ///
    /// <b>Border Values</b>
    ///
    /// All of the values outside of the noise map are assumed to have a
    /// common value known as the <i>border value</i>.
    ///
    /// To set the border value, call the SetBorderValue() method.
    ///
    /// The GetValue() method returns the border value if the specified value
    /// lies outside of the noise map.
    ///
    /// <b>Internal Noise Map Structure</b>
    ///
    /// Internally, the values are organized into horizontal rows called @a
    /// slabs.  Slabs are ordered from bottom to top.
    ///
    /// Each slab contains a contiguous row of values in memory.  The values
    /// in a slab are organized left to right.
    ///
    /// The offset between the starting points of any two adjacent slabs is
    /// called the <i>stride amount</i>.  The stride amount is measured by
    /// the number of @a float values between these two starting points, not
    /// by the number of bytes.  For efficiency reasons, the stride is often a
    /// multiple of the machine word size.
    ///
    /// The GetSlabPtr() and GetConstSlabPtr() methods allow you to retrieve
    /// pointers to the slabs themselves.
"
Class {
	#name : 'NuNoiseMap',
	#superclass : 'NuBaseObject',
	#category : 'LibNoiseutils-Utils',
	#package : 'LibNoiseutils',
	#tag : 'Utils'
}

{ #category : 'instance creation' }
NuNoiseMap class >> new [

	^ (self noiseMap_new) initialize
]

{ #category : 'instance creation' }
NuNoiseMap class >> newRhs: rhs [

	^ (self noiseMap_new: rhs) initialize
]

{ #category : 'instance creation' }
NuNoiseMap class >> newWidth: width height: height [

	^ (self noiseMap_newwidth: width height: height) initialize
]

{ #category : 'private' }
NuNoiseMap class >> noiseMap_new [
	"/// Constructor.
	 ///
	 /// Creates an empty noise map."

	self ffiCall: #(nu_noise_utils_NoiseMap* nu_noise_utils_NoiseMap_new_1())
]

{ #category : 'private' }
NuNoiseMap class >> noiseMap_new: rhs [
	"/// Copy constructor.
	 ///
	 /// @throw noise::ExceptionOutOfMemory Out of memory."

	self ffiCall: #(nu_noise_utils_NoiseMap* nu_noise_utils_NoiseMap_new_3(nu_noise_utils_NoiseMap* rhs))
]

{ #category : 'private' }
NuNoiseMap class >> noiseMap_newwidth: width height: height [
	"/// Constructor.
	 ///
	 /// @param width The width of the new noise map.
	 /// @param height The height of the new noise map.
	 ///
	 /// @pre The width and height values are positive.
	 /// @pre The width and height values do not exceed the maximum
	 /// possible width and height for the noise map.
	 ///
	 /// @throw noise::ExceptionInvalidParam See the preconditions.
	 /// @throw noise::ExceptionOutOfMemory Out of memory.
	 ///
	 /// Creates a noise map with uninitialized values.
	 ///
	 /// It is considered an error if the specified dimensions are not
	 /// positive."

	self ffiCall: #(nu_noise_utils_NoiseMap* nu_noise_utils_NoiseMap_new_2(int width, int height))
]

{ #category : 'public' }
NuNoiseMap >> clear: value [
	"/// Clears the noise map to a specified value.
	 ///
	 /// @param value The value that all positions within the noise map are
	 /// cleared to."

	self ffiCall: #(void nu_noise_utils_NoiseMap_Clear(nu_noise_utils_NoiseMap* self, float value))
]

{ #category : 'finalizing' }
NuNoiseMap >> dispose [

	self ffiCall: #(void nu_noise_utils_NoiseMap_dispose(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> getBorderValue [
	"/// Returns the value used for all positions outside of the noise map.
	 ///
	 /// @returns The value used for all positions outside of the noise
	 /// map.
	 ///
	 /// All positions outside of the noise map are assumed to have a
	 /// common value known as the <i>border value</i>."

	self ffiCall: #(float nu_noise_utils_NoiseMap_GetBorderValue(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> getConstSlabPtr [
	"/// Returns a const pointer to a slab.
	 ///
	 /// @returns A const pointer to a slab at the position (0, 0), or
	 /// @a NULL if the noise map is empty."

	self ffiCall: #(const float* nu_noise_utils_NoiseMap_GetConstSlabPtr_1(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> getConstSlabPtr: row [
	"/// Returns a const pointer to a slab at the specified row.
	 ///
	 /// @param row The row, or @a y coordinate.
	 ///
	 /// @returns A const pointer to a slab at the position ( 0, @a row ),
	 /// or @a NULL if the noise map is empty.
	 ///
	 /// @pre The coordinates must exist within the bounds of the noise
	 /// map.
	 ///
	 /// This method does not perform bounds checking so be careful when
	 /// calling it."

	self ffiCall: #(const float* nu_noise_utils_NoiseMap_GetConstSlabPtr_2(nu_noise_utils_NoiseMap* self, int row))
]

{ #category : 'public' }
NuNoiseMap >> getConstSlabPtrX: x y: y [
	"/// Returns a const pointer to a slab at the specified position.
	 ///
	 /// @param x The x coordinate of the position.
	 /// @param y The y coordinate of the position.
	 ///
	 /// @returns A const pointer to a slab at the position ( @a x, @a y ),
	 /// or @a NULL if the noise map is empty.
	 ///
	 /// @pre The coordinates must exist within the bounds of the noise
	 /// map.
	 ///
	 /// This method does not perform bounds checking so be careful when
	 /// calling it."

	self ffiCall: #(const float* nu_noise_utils_NoiseMap_GetConstSlabPtr_3(nu_noise_utils_NoiseMap* self, int x, int y))
]

{ #category : 'public' }
NuNoiseMap >> getHeight [
	"/// Returns the height of the noise map.
	 ///
	 /// @returns The height of the noise map."

	self ffiCall: #(int nu_noise_utils_NoiseMap_GetHeight(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> getMemUsed [
	"/// Returns the amount of memory allocated for this noise map.
	 ///
	 /// @returns The amount of memory allocated for this noise map.
	 ///
	 /// This method returns the number of @a float values allocated."

	self ffiCall: #(int nu_noise_utils_NoiseMap_GetMemUsed(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> getSlabPtr [
	"/// Returns a pointer to a slab.
	 ///
	 /// @returns A pointer to a slab at the position (0, 0), or @a NULL if
	 /// the noise map is empty."

	self ffiCall: #(float* nu_noise_utils_NoiseMap_GetSlabPtr_1(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> getSlabPtr: row [
	"/// Returns a pointer to a slab at the specified row.
	 ///
	 /// @param row The row, or @a y coordinate.
	 ///
	 /// @returns A pointer to a slab at the position ( 0, @a row ), or
	 /// @a NULL if the noise map is empty.
	 ///
	 /// @pre The coordinates must exist within the bounds of the noise
	 /// map.
	 ///
	 /// This method does not perform bounds checking so be careful when
	 /// calling it."

	self ffiCall: #(float* nu_noise_utils_NoiseMap_GetSlabPtr_2(nu_noise_utils_NoiseMap* self, int row))
]

{ #category : 'public' }
NuNoiseMap >> getSlabPtrX: x y: y [
	"/// Returns a pointer to a slab at the specified position.
	 ///
	 /// @param x The x coordinate of the position.
	 /// @param y The y coordinate of the position.
	 ///
	 /// @returns A pointer to a slab at the position ( @a x, @a y ) or
	 /// @a NULL if the noise map is empty.
	 ///
	 /// @pre The coordinates must exist within the bounds of the noise
	 /// map.
	 ///
	 /// This method does not perform bounds checking so be careful when
	 /// calling it."

	self ffiCall: #(float* nu_noise_utils_NoiseMap_GetSlabPtr_3(nu_noise_utils_NoiseMap* self, int x, int y))
]

{ #category : 'public' }
NuNoiseMap >> getStride [
	"/// Returns the stride amount of the noise map.
	 ///
	 /// @returns The stride amount of the noise map.
	 ///
	 /// - The <i>stride amount</i> is the offset between the starting
	 ///   points of any two adjacent slabs in a noise map.
	 /// - The stride amount is measured by the number of @a float values
	 ///   between these two points, not by the number of bytes."

	self ffiCall: #(int nu_noise_utils_NoiseMap_GetStride(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> getValueX: x y: y [
	"/// Returns a value from the specified position in the noise map.
	 ///
	 /// @param x The x coordinate of the position.
	 /// @param y The y coordinate of the position.
	 ///
	 /// @returns The value at that position.
	 ///
	 /// This method returns the border value if the coordinates exist
	 /// outside of the noise map."

	self ffiCall: #(float nu_noise_utils_NoiseMap_GetValue(nu_noise_utils_NoiseMap* self, int x, int y))
]

{ #category : 'public' }
NuNoiseMap >> getWidth [
	"/// Returns the width of the noise map.
	 ///
	 /// @returns The width of the noise map."

	self ffiCall: #(int nu_noise_utils_NoiseMap_GetWidth(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> reclaimMem [
	"/// Reallocates the noise map to recover wasted memory.
	 ///
	 /// @throw noise::ExceptionOutOfMemory Out of memory.  (Yes, this
	 /// method can return an out-of-memory exception because two noise
	 /// maps will temporarily exist in memory during this call.)
	 ///
	 /// The contents of the noise map is unaffected."

	self ffiCall: #(void nu_noise_utils_NoiseMap_ReclaimMem(nu_noise_utils_NoiseMap* self))
]

{ #category : 'public' }
NuNoiseMap >> setBorderValue: borderValue [
	"/// Sets the value to use for all positions outside of the noise map.
	 ///
	 /// @param borderValue The value to use for all positions outside of
	 /// the noise map.
	 ///
	 /// All positions outside of the noise map are assumed to have a
	 /// common value known as the <i>border value</i>."

	self ffiCall: #(void nu_noise_utils_NoiseMap_SetBorderValue(nu_noise_utils_NoiseMap* self, float borderValue))
]

{ #category : 'public' }
NuNoiseMap >> setSizeWidth: width height: height [
	"/// Sets the new size for the noise map.
	 ///
	 /// @param width The new width for the noise map.
	 /// @param height The new height for the noise map.
	 ///
	 /// @pre The width and height values are positive.
	 /// @pre The width and height values do not exceed the maximum
	 /// possible width and height for the noise map.
	 ///
	 /// @throw noise::ExceptionInvalidParam See the preconditions.
	 /// @throw noise::ExceptionOutOfMemory Out of memory.
	 ///
	 /// On exit, the contents of the noise map are undefined.
	 ///
	 /// If the @a OUT_OF_MEMORY exception occurs, this noise map object
	 /// becomes empty.
	 ///
	 /// If the @a INVALID_PARAM exception occurs, the noise map is
	 /// unmodified."

	self ffiCall: #(void nu_noise_utils_NoiseMap_SetSize(nu_noise_utils_NoiseMap* self, int width, int height))
]

{ #category : 'public' }
NuNoiseMap >> setValueX: x y: y value: value [
	"/// Sets a value at a specified position in the noise map.
	 ///
	 /// @param x The x coordinate of the position.
	 /// @param y The y coordinate of the position.
	 /// @param value The value to set at the given position.
	 ///
	 /// This method does nothing if the noise map object is empty or the
	 /// position is outside the bounds of the noise map."

	self ffiCall: #(void nu_noise_utils_NoiseMap_SetValue(nu_noise_utils_NoiseMap* self, int x, int y, float value))
]

{ #category : 'public' }
NuNoiseMap >> takeOwnership: source [
	"/// Takes ownership of the buffer within the source noise map.
	 ///
	 /// @param source The source noise map.
	 ///
	 /// On exit, the source noise map object becomes empty.
	 ///
	 /// This method only moves the buffer pointer so this method is very
	 /// quick."

	self ffiCall: #(void nu_noise_utils_NoiseMap_TakeOwnership(nu_noise_utils_NoiseMap* self, nu_noise_utils_NoiseMap* source))
]
